<!doctype html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8">
    <meta name="baidu-site-verification" content="dIcXMeY8Ya">
    
    <title>设计模式 | 秋泽雨</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <meta name="keywords" content="秋泽雨、全栈开发">
    <meta name="description" content="秋泽雨的个人小站">

    
    <link rel="alternative" href="/atom.xml" title="秋泽雨" type="application/atom+xml">
    
    
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->
    
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?fd459238242776d173cdc64918fb32f2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</head>
</html>
<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">秋泽雨</span>
                    <span class="description">秋泽雨小站</span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/2019/10/17/设计模式/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/2019/10/17/设计模式/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/spcBackToLife/" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.coding.me" target="_blank">Hosted by Coding Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/headIcon.jpg" alt="avatar" title="Jelon" >
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 文章页 -->
<!-- 文章 -->
<article class="post article">
    <header class="text-center">
        <h3 class="post-title"><span>设计模式</span></h3>
    </header>
    <p class="post-meta text-center">
        秋泽雨 发表于
        <time datetime="2019-10-17T02:42:33.000Z">2019-10-17</time>
    </p>
    <div class="post-content">
        <h2 id="设计模式概念"><a href="#设计模式概念" class="headerlink" title="设计模式概念"></a>设计模式概念</h2><p>总体来说设计模式分为三大类：</p>
<p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<a id="more"></a>
<h2 id="二、设计模式的六大原则"><a href="#二、设计模式的六大原则" class="headerlink" title="二、设计模式的六大原则"></a>二、设计模式的六大原则</h2><p>总原则： 开闭原则</p>
<ol>
<li>对扩展开放，对修改关闭<ol>
<li>单一职责原则（职责即类改变的原因）</li>
</ol>
</li>
</ol>
<pre><code>不要存在多余1个导致类变更的原因，如果有多个，则表示有多个职责，他们会耦合在一起。
一个职责的变化，则会导致其余职责来兼容，削弱了执行其余职责的能力。

解决方式是：解耦和提高内聚性。</code></pre><ol start="2">
<li>里式替换原则（开闭原则的补充）</li>
</ol>
<pre><code>任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石。
只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用；
而衍生类也能够在基类的基础上增加新的行为。</code></pre><ol start="3">
<li>依赖倒转原则（开闭原则的基础）</li>
</ol>
<pre><code>面向接口编程，依赖于抽象而不依赖于具体。
写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</code></pre><ol start="4">
<li>接口隔离原则</li>
</ol>
<pre><code>每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。
使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</code></pre><ol start="5">
<li><p>迪米特法则（最少知道原则）</p>
<pre><code>只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。
我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。
1我们要求陌生的类不要作为局部变量出现在类中。</code></pre></li>
<li><p>合成复用原则</p>
</li>
</ol>
<pre><code>原则是尽量首先使用合成/聚合的方式，而不是使用继承。</code></pre><p>创建性模式：简单工厂、方法工厂、单例、建造者、原型</p>
<p>结构型模式：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式</p>
<p>一、方法工厂模式</p>
<ol>
<li><p>将继承统一接口的一些类，在创建对象的时候统一管理。</p>
</li>
<li><p>依赖倒转原则、里式替换原则、高内聚、低耦合。</p>
</li>
<li><p>更换新的角色、增加新的角色，都能够更加方便，改动少。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的工厂模式。</span></span><br><span class="line"><span class="comment">// 不利于扩展、不符合开闭。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">(String logType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"Log1"</span>.equals(logType))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Log1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"Log2"</span>.equals(logType))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Log2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法工厂模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerFactory</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IFactory iFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iFactory.getLogger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Logger <span class="title">getLogger</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log1Factory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Logger <span class="title">getLogger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Log1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>二、单例模式</p>
<ol>
<li>主要应用于需要单个实例的场景（比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。）</li>
<li>这样子省资源，创建实例很耗费资源，又没有必要过多创建实例。</li>
<li>需要注意：何时加载？单线程？线程安全？</li>
</ol>
<p>三、建造者模式</p>
<ol>
<li><p>它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。（汽车）</p>
</li>
<li><p>优点：</p>
<ol>
<li><strong>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</strong></li>
<li><strong>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。</strong></li>
<li><strong>可以更加精细地控制产品的创建过程</strong> 。</li>
<li><strong>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合 “开闭原则”</strong></li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>产品之间差异很大，不建议。（汽车族、轮船、飞机=&gt; 运输工具）</li>
<li>产品内部变化复杂，不建议。</li>
</ol>
</li>
<li><p>高扩展性、符合开闭原则、依赖倒转原则。（kfc套餐）</p>
</li>
</ol>
<p>四、适配器模式</p>
<ol>
<li><p>类的适配器模式（里式替换原则）</p>
<ol>
<li><p>(1)目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。</p>
<p>(2)源(Adapee)角色：现在需要适配的接口。</p>
<p>(3)适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。</p>
</li>
</ol>
</li>
<li><p>对象的适配器模式</p>
</li>
<li><p>接口的适配器模式</p>
</li>
<li><p>何时使用：</p>
</li>
</ol>
<p>(1)类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。</p>
<p>(2)对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个包装类，持有原类的一个实例，在包装类的方法中，调用实例的方法就行。</p>
<p>五、装饰者模式</p>
<ol>
<li><p>装饰器模式的应用场景：</p>
<p>1、需要扩展一个类的功能。</p>
<p>2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）</p>
<p>缺点：产生过多相似的对象，不易排错！</p>
</li>
<li><p>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IThirdParty thirdPartyOne =<span class="keyword">new</span> ThirdParty();</span><br><span class="line">　　IThirdParty decorator1 =<span class="keyword">new</span> Decorator1(thirdPartyOne);</span><br><span class="line">　　IThirdParty decorator2 =<span class="keyword">new</span> Decorator2(decorator1);</span><br><span class="line">　　</span><br><span class="line">　　System.out.println(decorator2.sayMsg());</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>本身就是针对源对象的方法执行前后做处理，即为装饰。采取的方式，就是使用一个包换源对象需要装饰的方法的接口，其余装饰者都实现这个接口即可。并且每个装饰者里都有这个源对象作为自己的一个属性。</li>
<li>组合的情况很多的时候，比如调酒，原料和其余组合起来有很多很多情况。</li>
<li>符合开闭原则</li>
</ol>
<p>六、代理模式</p>
<ol>
<li><p>和装饰者实现角度类似，只是说使用角度是，代替源对象做一些事情，并且再源对象前后做一些事。因为源对象信息不够全面的时候。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Source source;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>();  </span><br><span class="line">        <span class="keyword">this</span>.source = <span class="keyword">new</span> Source();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        before();  </span><br><span class="line">        source.method();  </span><br><span class="line">        atfer();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">atfer</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"after proxy!"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"before proxy!"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然而，实际上，在装饰器模式和代理模式之间还是有很多差别的。装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</p>
</li>
</ol>
<p>七、外观模式</p>
<ol>
<li><p>外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> CPU cpu;  </span><br><span class="line">    <span class="keyword">private</span> Memory memory;  </span><br><span class="line">    <span class="keyword">private</span> Disk disk;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        cpu = <span class="keyword">new</span> CPU();  </span><br><span class="line">        memory = <span class="keyword">new</span> Memory();  </span><br><span class="line">        disk = <span class="keyword">new</span> Disk();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"start the computer!"</span>);  </span><br><span class="line">        cpu.startup();  </span><br><span class="line">        memory.startup();  </span><br><span class="line">        disk.startup();  </span><br><span class="line">        System.out.println(<span class="string">"start computer finished!"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"begin to close the computer!"</span>);  </span><br><span class="line">        cpu.shutdown();  </span><br><span class="line">        memory.shutdown();  </span><br><span class="line">        disk.shutdown();  </span><br><span class="line">        System.out.println(<span class="string">"computer closed!"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>八、桥接模式</p>
<ol>
<li><p>你有多个工具要使用的时候，为了可以自由切换，你需要一个桥，一个adapter。你使用的时候，只需要告诉他你要哪个工具，然后你使用的时候就会用那个工具。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">          </span><br><span class="line">        Bridge bridge = <span class="keyword">new</span> MyBridge();  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">/*调用第一个对象*/</span>  </span><br><span class="line">        Sourceable source1 = <span class="keyword">new</span> SourceSub1();  </span><br><span class="line">        bridge.setSource(source1);  </span><br><span class="line">        bridge.method();  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">/*调用第二个对象*/</span>  </span><br><span class="line">        Sourceable source2 = <span class="keyword">new</span> SourceSub2();  </span><br><span class="line">        bridge.setSource(source2);  </span><br><span class="line">        bridge.method();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>九、组合模式</p>
<ol>
<li><p>组合模式有时又叫<strong>部分-整体</strong>模式在处理类似树形结构的问题时比较方便。（二叉树）</p>
</li>
<li><p>根节点和叶子节点需要实现相同的接口。根节点存储着许多children节点。</p>
</li>
<li><p>优点：</p>
<ol>
<li>可以一致的处理对象容器和对象，无需关心单个对象还是容器。</li>
<li>将客户端与复杂的对象容器结构。</li>
</ol>
</li>
<li><p>缺点：容器中不能指定特定对象，只有在运行时候做类型检查。</p>
</li>
<li><p>主要的特点就是统一的去处理叶子和容器。</p>
</li>
<li><p>客户端尽量不要直接调用树叶类中的方法（在我上面实现就是这样的，创建的是一个树枝的具体对象;），而是借用其父类（Graphics）的多态性完成调用，这样可以增加代码的复用性。</p>
</li>
<li><p>目录结构、应用软件中的菜单、办公系统中的公司组织结构，均可用。</p>
</li>
<li><p>透明模式和安全模式</p>
</li>
</ol>
<p>十、享元模式</p>
<ol>
<li>享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。</li>
</ol>
<p>十一、策略模式</p>
<ol>
<li><p>策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数。</p>
</li>
<li><p>实际上所有模式可以只分为类模式和对象模式两种，类模式是用继承而对象模式是用委托Bridge模式和Strategy模式相似就是因为他们都将任务委托给了另外一个接口的具体实现，他们之间的区别在于Bridge的目的是让底层实现和上层接口可以分别演化，从而提高移植性而Strategy的目的是将复杂的算法封装起来，从而便于替换不同的算法。因此可以想象一般情况下Bridge的实现几乎不会在运行时更改而Strategy的算法则很有可能需要在运行时更换，这就导致在细节方面需要考虑的因素可能会很不相同。</p>
</li>
<li><p>strategy模式是为了扩展和修改，并提供动态配置。它往往可以在同一环境当中使用不同的策略，就是调用不同的派生类。其内部实现是自由的，不受已有的类接口的限制（很多时候根本就不调用现成的接口）。bridge模式是往往是为了利用已有的方法或类。它将原来不统一，不兼容的接口封装起来，变成统一的接口。它的应用往往是不同的环境或平台下只能选择一 种，比如说在windows平台下只能用WinClass,而在unix平台下只能用UnixClass.它的主要作用不是配置而是定义通用接口。</p>
</li>
<li><p>桥接(Bridge)模式是结构型模式的一种，而策略(strategy)模式则属于行为模式.</p>
</li>
<li><p>桥接模式表达的主要意义其实是接口隔离的原则，即把本质上并不内聚的两种体系区别 开来，使得它们可以松散的组合.</p>
</li>
<li><p>策略在解耦上还仅仅是某一个算法的层次，没有到体系这一层次。</p>
</li>
<li><p>策略仅仅是考虑算法的替换，而桥接考虑的则是不同平台下须要调用不同的工具，接口仅仅是定义一个方法。</p>
</li>
</ol>
<p>十二、模板方法模式</p>
<ol>
<li>主要是使用抽象类，将一般的方法实现，将不相同实现的方法抽象。可以实现代码的复用性更好。</li>
</ol>
<p>十三、观察者模式</p>
<ol>
<li>就是注册观察者，在被观察对象改变后，通知观察者。</li>
</ol>

    </div>
    <p class="post-meta">
        <span class="post-cat">分类：
            <a class="cat-link" href="/categories/设计模式/">设计模式</a>
        </span>
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/设计模式/" title="设计模式">设计模式</a>
    

        </span>
    </p>
</article>
<!-- 分享按钮 -->

  <div class="article-share clearfix text-center">
    <div class="share-area">
      <span class="share-txt">分享到：</span>
      <a href="javascript: window.open('http://service.weibo.com/share/share.php?url=' + encodeURIComponent(location.href) + '&title=' + document.title + '&language=zh_cn');" class="share-icon weibo"></a>
      <a href="javascript: alert('请复制链接到微信并发送');" class="share-icon wechat"></a>
      <a href="javascript: window.open('http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=' + encodeURIComponent(location.href) + '&title=' + document.title);" class="share-icon qqzone"></a>
      <a href="javascript: window.open('http://connect.qq.com/widget/shareqq/index.html?url=' + encodeURIComponent(location.href) + '&desc=Jelon个人博客&title=' + document.title + '&callback=' + encodeURIComponent(location.href));" class="share-icon qq"></a>
      <a href="javascript: window.open('http://shuo.douban.com/!service/share?href=' + encodeURIComponent(location.href) + '&name=' + document.title + '&text=' + document.title);" class="share-icon douban"></a>
    </div>
  </div>


<!-- 上一篇/下一篇 -->

<div class="article-nav clearfix">
    
    <span class="prev fl">
        上一篇<br >
        <a href="javascript: void(0);">没有上一篇了</a>
    </span>
    

    
    <span class="next fr">
        下一篇<br >
        <a href="/2019/10/16/Electron-主进程、渲染进程/">
            
                Electron-主进程、渲染进程
            
        </a>
    </span>
    
</div>

<!-- 文章评论 -->

  <script src="/js/comment.js"></script>
  <div id="comments" class="comment">
    <!--
    <div class="sign-bar">
      GitHub 已登录!
      <span class="sign-link">登出</span>
    </div>
    <section class="box">
      <div class="com-avatar"><img src="/img/jelon.jpg" alt="avatar"></div>
      <div class="com-text">
        <div class="main">
          <textarea class="text-area-edited show" placeholder="欢迎评论！"></textarea>
          <div class="text-area-preview"></div>
        </div>
        <div class="switch">
          <div class="switch-item on">编辑</div>
          <div class="switch-item">预览</div>
        </div>
        <div class="button">提交</div>
      </div>
    </section>
    <section class="tips">注：评论支持 markdown 语法！</section>
    <section class="list-wrap">
      <ul class="list">
        <li>
          <div class="user-avatar">
            <a href="/">
              <img src="/img/jelon.jpg" alt="user-avatar">
            </a>
          </div>
          <div class="user-comment">
            <div class="user-comment-header">
              <span class="post-name">张德龙</span>
              <span class="post-time">2017年12月12日</span>
              <span class="like liked">已赞</span>
              <span class="like-num">2</span>
            </div>
            <div class="user-comment-body">333333</div>
          </div>
        </li>
        <li>
          <div class="user-avatar">
            <a href="/">
              <img src="/img/jelon.jpg" alt="user-avatar">
            </a>
          </div>
          <div class="user-comment">
            <div class="user-comment-header">
              <span class="post-name">刘德华</span>
              <span class="post-time">2017年12月12日</span>
              <span class="like">点赞</span>
              <span class="like-num">2</span>
            </div>
            <div class="user-comment-body">vvvvv</div>
          </div>
        </li>
      </ul>
      <div class="page-nav">
        <a href="javascript: void(0);" class="item">1</a>
        <a href="javascript: void(0);" class="item">2</a>
        <a href="javascript: void(0);" class="item current">3</a>
      </div>
    </section>
    -->
  </div>
  <script>
  JELON.Comment({
    container: 'comments',
    label: '设计模式' || '2019/10/17/设计模式/',
    owner: 'spcBackToLife',
    repo: 'spcBackToLife.github.io',
    clientId: '36f5037c3e1209eaddc1',
    clientSecret: '038a6d949d922e4d9d0d18d1d7b8c301f175bbab'
  });
  </script>


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/Electron/">Electron</a>
        <span class="badge">(5)</span>
    </li>
    
    <li>
        <a href="/categories/Node/">Node</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/github/">github</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/RabbitMQ/">RabbitMQ</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/项目管理/">项目管理</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/Node/Webpack/">Webpack</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/Node/Webpack/Typescript/">Typescript</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/设计模式/">设计模式</a>
        <span class="badge">(1)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="/tags/博客/" title="博客">博客 (4)</a>
  
    <a class="tag-item" href="/tags/Electron/" title="Electron">Electron (4)</a>
  
    <a class="tag-item" href="/tags/Problems/" title="Problems">Problems (2)</a>
  
    <a class="tag-item" href="/tags/webpack4/" title="webpack4">webpack4 (2)</a>
  
    <a class="tag-item" href="/tags/node/" title="node">node (2)</a>
  
    <a class="tag-item" href="/tags/typescript/" title="typescript">typescript (2)</a>
  
    <a class="tag-item" href="/tags/hotReload/" title="hotReload">hotReload (1)</a>
  
    <a class="tag-item" href="/tags/github/" title="github">github (1)</a>
  
    <a class="tag-item" href="/tags/comment/" title="comment">comment (1)</a>
  
    <a class="tag-item" href="/tags/RabbitMQ/" title="RabbitMQ">RabbitMQ (1)</a>
  
    <a class="tag-item" href="/tags/java/" title="java">java (1)</a>
  
    <a class="tag-item" href="/tags/项目管理/" title="项目管理">项目管理 (1)</a>
  
    <a class="tag-item" href="/tags/主进程/" title="主进程">主进程 (1)</a>
  
    <a class="tag-item" href="/tags/渲染进程/" title="渲染进程">渲染进程 (1)</a>
  
    <a class="tag-item" href="/tags/设计模式/" title="设计模式">设计模式 (1)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="https://github.com/spcBackToLife/" target="_blank" title="秋泽雨的github">Github</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2019
    

    <a href="/">Jelon Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->
<script src="/js/main.js"></script>
</body>
</html>